<!DOCTYPE html><html><head><meta charset="utf-8"><title>reveal.js – The HTML Presentation Framework</title><meta name="description" content="A framework for easily creating beautiful presentations using HTML"><meta name="author" content="Hakim El Hattab"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><link rel="stylesheet" href="reveal/css/reveal.css"><link rel="stylesheet" href="reveal/css/theme/black.css" id="theme"><link rel="stylesheet" href="css/style.css"><!-- Code syntax highlighting -->
<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
<!-- Printing and PDF exports --><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script><!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]--></head><body><div></div><div class="reveal"><div class="slides">\( 
  \newcommand{\ord}[1]{\mathcal{O}\left(#1\right)}
  \newcommand{\abs}[1]{\lvert #1 \rvert}
  \newcommand{\floor}[1]{\lfloor #1 \rfloor}
  \newcommand{\ceil}[1]{\lceil #1 \rceil}
  \newcommand{\opord}{\operatorname{\mathcal{O}}}
  \newcommand{\fail}{\operatorname{\mathcal{F}}}
  \newcommand{\flk}{\operatorname{\mathfrak{F}}}
  \newcommand{\suf}{\operatorname{\sigma}}
  \newcommand{\rank}{\operatorname{\mathcal{R}}}
  \newcommand{\sa}{\operatorname{\mathcal{SA}}}
  \newcommand{\hei}{\operatorname{\mathcal{H}}}
  \newcommand{\edps}{\operatorname{\mathcal{E}}}
  \newcommand{\mx}{\operatorname{\mathcal{M}}}
  \newcommand{\argmax}{\operatorname{arg\,max}}
  \newcommand{\cons}[1]{\left[ \: #1 \: \right]}
  \newcommand{\str}[1]{\texttt{"#1"}}
\)<section><h1>組合賽局</h1><p><div class="small">Created by STEP5</div></p></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>簡介</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>賽局理論?</h2><ul><li>研究鬥爭或競爭行為的數學方法</li><li>計算能夠獲得最大利益的最佳策略</li><li>又稱為**博弈**論</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>囚犯困局</h2><table><tr> <td> </td><td>甲不認罪</td><td>甲認罪</td></tr><tr> <td>乙不認罪 </td><td>二人同服刑半年</td><td>甲獲釋；乙服刑10年</td></tr><tr> <td>乙認罪</td><td>甲服刑10年；乙獲釋</td><td>**二人同服刑5年**</td></tr></table><br><br><h3 class="fragment">不過這不是我們的重點</h3></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2><font color="red">組合</font>賽局</h2><ul><li class="fragment">兩位玩家對戰，雙方輪流操作</li><li class="fragment">資訊完全公開</li><li class="fragment">決定性</li><li class="fragment">必在有限步內結束</li><li class="fragment">零和 (Zero-sum)</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2><font color="red">組合</font>賽局</h2><ul><li class="fragment">OOXX</li><li class="fragment">五子棋、象棋、西洋棋、圍棋</li><li class="fragment">各種撿石頭</li></ul></script></section></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>Game Graph</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>Game Graph</h2><ul><li class="fragment">遊戲是**決定性**的！</li><li class="fragment">用<font color="red">圖</font> (Graph) 來表示</li></ul><br><br><h3 class="fragment">盤面 -> 狀態 -> <font color="blue">點 ($V$)</font></h3><h3 class="fragment">操作 -> 轉移 -> <font color="green">邊 ($F$)</font></h3><h3 class="fragment">$G = (V, F)$</h3></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>Game Graph</h2><ul><li class="fragment">遊戲**必定會結束**</li><li class="fragment">Directed <font color="red">Acyclic</font> Graph (DAG)!</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><img width="80%" src="img/graph.png"><ul><li>起始狀態</li><li>結束狀態</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>遊戲策略</h2><ul><li class="fragment"><font color="blue">先手</font> / <font color="green">後手</font></li><li class="fragment"><font color="blue">鉀方</font> / <font color="green">釔方</font></li><li class="fragment">每個結束局面都有一個<font color="blue">鉀方</font>獲利值 $x$</li><li class="fragment"><font color="blue">鉀方</font> 想要讓 $x$ 值**最大化**</li><li class="fragment"><font color="green">釔方</font> 想要讓 $x$ 值**最小化**</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>假設**每個**盤面 $S$ 都有一個固定的<font color="blue">鉀方</font>獲利值 $x(S)$</p><p>那麼如果 $S$ 不是結束局面的話</p>$$x(S) = 
\begin{cases}
\max x(u), u \in F(S) &, \text{if 輪到鉀方} \\\\ 
\min x(u), u \in F(S) &, \text{if 輪到釔方}
\end{cases}
$$</script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>可是真的每個盤面都有固定的獲利值嗎？</p><h2 class="fragment">YES !!</h2><ul><li class="fragment">DAG 存在 拓樸順序(Topological order)</li><li class="fragment">結束盤面存在 $x(S)$</li><li class="fragment">數學歸納法！</li><li class="fragment">真的嗎...?</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>還要證明鉀方的獲利值確實固定是 $x(S)$ ！</p><ul><li class="fragment">不論釔方怎麼走，鉀方總是可以讓自己獲利值 $\geq x(S)$</li><li class="fragment">不論鉀方怎麼走，釔方總是可以讓對手獲利值 $\leq x(S)$</li><li class="fragment">雙方都使用最佳策略的話，最終獲利值就是 $x(S)$ ！</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="theorem"><div class="label">定理</div><hr>設初始盤面為 $R$ ，則如果雙方都使用最佳策略，那麼鉀方最終獲利值一定是 $x(R)$。
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>那麼要如何計算 $x(S)$ 值呢？</h3><ul><li class="fragment">DAG 有拓樸順序</li><li class="fragment">Dynamic Programming !</li><li class="fragment">$O(V+F)$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>如果遊戲只分**輸贏**呢？</p><ul><li class="fragment">OOXX</li><li class="fragment">五子棋、象棋、...</li></ul><p class="fragment">定義獲利值：勝利 = $+1$，落敗 = $-1$</p></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="theorem"><div class="label">定理</div>必勝策略<hr>對於一個只分輸贏的遊戲，如果 $x(R) = +1$ ，則先手必勝；如果 $x(R) = -1$ ，則後手必勝。
</div><br><h3 class="fragment">沒錯，遊戲結果也是決定性的！</h3></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>所以，我們就這樣破解了所有遊戲？</p><h3 class="fragment">當然沒有！</h3><h3 class="fragment">$O(\color{red}{V} + \color{blue}{F})$</h3><ul class="fragment"><li>OOXX : $\color{red}{V} \approx 10^5$</li><li>象棋 : $\color{red}{V} \approx 10^{40}$</li><li>西洋棋 : $\color{red}{V} \approx 10^{47}$</li><li>圍棋 : $\color{red}{V} \approx 10^{170}$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>各種剪枝、各種 Heuristic</p><img width="40%" src="img/alphago.jpg"><img width="50%" src="img/alphago2.jpg"></script></section></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>對稱遊戲</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>不論是先手或後手，面對同一個盤面，可以進行的操作集合是一樣的。</p><ul><li class="fragment">OOXX ? </li><li class="fragment">圍棋 ? </li><li class="fragment">撿石頭 !</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li>不在意誰是整局遊戲的先手</li><li>重要的是**接下來的一方**輸或贏</li></ul><br><br>$$ x(S) = 
\begin{cases}
+1 &, \text{接下來的一方贏} \\\\
-1 &, \text{接下來的一方輸}
\end{cases}
$$</script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>遞迴式也變得比較簡單</p><p>$$ x(S) = -\min x(u), u \in F(S)$$</p><div class="theorem"><div class="label">定理</div>對稱遊戲遞迴規則<hr>如果 $S$ 不是結束盤面，
$$ x(S) = \begin{cases}+1 &, \text{可以走到至少一個 -1} \\\\ -1 &, \text{otherwise}\end{cases}$$</div><p class="fragment">常用結束條件：不能動的一方輸</p><p class="fragment">=> $S$ 是結束盤面也適用！</p></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>另一種常用的表示法</h3><ul><li>$x(S) = +1$ : <font color="blue">N</font>-position, <font color="blue">N</font>ext player win</li><li>$x(S) = -1$ : <font color="green">P</font>-position, <font color="green">P</font>revious player win</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>撿石頭<hr>老鼠窩裡有 $N$ 個石頭，兩人輪流拿，每次可以拿走 $1 \sim 3$ 顆，拿到最後一顆的一方贏。請問先手還後手必勝？ ($1 \leq N \leq 10^{18}$)
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><table align="left"><tr><td>$n$</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td>$x(n)$</td><td>$-1$</td><td>$+1$</td><td>$+1$</td><td>$+1$</td><td>$-1$</td><td>$+1$</td><td>$+1$</td><td>$+1$</td><td>$-1$</td><td>$+1$</td><td>$+1$</td><td>$+1$</td><td>$-1$</td></tr></table><br><br><br><h3 class="fragment">必勝策略：每次拿到剩 $4$ 的倍數</h3></script></section></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>Nim</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>Nim (Easy)<hr>螞蟻窩裡有 $N$ 個石頭，兩人輪流拿，每次可以拿走**任意多顆**(但至少要拿$1$顆)，拿到最後一顆的一方贏。請問先手還後手必勝？ ($1 \leq N \leq 10^{18}$)
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>Nim (Medium)<hr>蟑螂窩裡有 $2$ 堆石頭，分別是 $A, B$ 個，兩人輪流拿，每次可以從一堆拿走**任意多顆**(但至少要拿$1$顆，且一次只能從同一堆拿)，拿到最後一顆的一方贏。請問先手還後手必勝？ ($1 \leq A, B \leq 10^{18}$)
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li class="fragment">$A = B$ : 後手必勝！</li><div class="fragment">先手拿一堆 $k$ 個，後手模仿他另一堆 $k$ 個</div><div class="fragment">後手永遠拿得到最後一個</div><br><li class="fragment">$A \neq B$ : 先手必勝！</li><div class="fragment">第一步把多的那堆拿到跟少的一樣</div></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>Nim (Final)<hr>垃圾場裡有 $N$ 堆石頭，分別是 $a_1, a_2, \cdots, a_N$ 個，兩人輪流拿，每次可以從一堆拿走**任意多顆**(但至少要拿$1$顆，且一次只能從同一堆拿)，拿到最後一顆的一方贏。請問先手還後手必勝？ ($1 \leq N \leq 10^6, 1 \leq a_i \leq 10^{18}$)
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>神奇的結論</h3><div class="theorem"><div class="label">定理</div>Nim<hr>定義一個盤面的**特徵值**為 $$X = a_1 \oplus a_2 \oplus \cdots \oplus a_N$$

此盤面**先手必勝**，若且唯若 $X \neq 0$ 。
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>還記得嗎?</p><p>$$ x(S) = \begin{cases}+1 &, \text{可以走到至少一個 -1} \\\\ -1 &, \text{otherwise}\end{cases}$$</p><p class="fragment">合法的 $x(S)$ 值是唯一的！</p><p class="fragment">我們只要證明剛才的定理符合此規則就好了：</p><ul class="fragment"><li>$X=0$ 的狀態無法走到其他 $X=0$ 的狀態</li><li>$X\neq 0$ 的狀態必定可以走到至少一個 $X=0$ 的狀態</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>$X=0$ 的狀態無法走到其他 $X=0$ 的狀態</h3><ul><li class="fragment">必須從一堆中拿掉一些石頭</li><li class="fragment">其中一個 $a_i$ 變小</li><li class="fragment">$a_i$ 必有 Bit 變化</li><li class="fragment">其他 $a$ 值沒變</li><li class="fragment">全部 XOR 起來必有 Bit 變化</li><li class="fragment">$X' \neq 0$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>$X\neq 0$ 的狀態必可以走到至少一個 $X=0$ 的狀態</h3><ul><li class="fragment">假設 $X$ 最高位為第 $k$ 位</li><li class="fragment">至少一個 $a_i$ 的第 $k$ 位為 $1$ </li><li class="fragment">如果把 $a_i$ 拿成 $a_i \oplus X$，新的 $X$ 就變 $0$ 了！</li><li class="fragment">而且 $a_i$ 一定會變小！</li></ul><br><br><h1 class="fragment">[喵]</h1></script></section></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>Sprague-Grundy Theorem</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li class="fragment">Nim 其實是很多團<font color="green">廢</font>遊戲組合起來</li><li class="fragment">每次只能挑一團動一步</li><li class="fragment"><font color="green">廢</font>遊戲組合起來就這麼難，那麼萬一是一般遊戲呢？</li><li class="fragment">安啦！</li></ul><br><br><h2 class="fragment"><font color="red">S</font>prague-<font color="blue">G</font>rundy Theorem !</h2><h2 class="fragment"><font color="red">死</font>布拉格-<font color="blue">個</font>浪底 定理！</h2></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>對於任意的遊戲盤面，可以定義類似 Nim 一樣的特徵值:</p><h2 class="fragment"><font color="red">S</font><font color="blue">G</font> Value (<font color="red">死</font><font color="blue">個</font>數值)</h2></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="theorem"><div class="label">定理</div>SG Value<hr>對於一個遊戲盤面 $S$ ，定義其 <font color="red">S</font><font color="blue">G</font> Value 為其可以走到的狀態的 <font color="red">S</font><font color="blue">G</font> Value 中，**最小沒出現的**非負整數。

$$ SG(S) = \mathrm{mex}\\\{SG(x) : x \in F(S)\\\}$$
$$ \mathrm{mex}(S) = \min\\\{i : i \in \mathbb{N} \backslash S\\\} $$
</div><p class="fragment">例如: $\mathrm{mex}(\\\{0, 1, 2, 4, 6\\\}) = 3$</p><h3 class="fragment">有沒有跟 Nim 很像？</h3></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p><font color="red">S</font><font color="blue">G</font> Value 可以視為 $x(S)$ 值的強化版：</p><div class="theorem"><div class="label">定理</div><hr>盤面 $S$ 為先手必勝，若且唯若 $SG(S) \neq 0$。</div><ul><li class="fragment">從定義就看得出來</li><li class="fragment">$SG = 0$ 走不到 $SG = 0$</li><li class="fragment">$SG \neq 0$ 走得到至少一個 $SG = 0$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><p>不過 <font color="red">S</font><font color="blue">G</font> Value 厲害的其實是...</p><h2 class="fragment">他可以像 Nim 特徵值一樣隨便 XOR !!</h2></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="theorem"><div class="label">定理</div>Game Sum<hr>假設 $S_1, S_2$ 是兩個獨立的遊戲，他們的**和** $S_1 + S_2$ 代表將兩個遊戲擺在一起形成的新遊戲。每次操作只能從 $S_1, S_2$ 挑一邊動一步。也就是說，
$$ F(S_1 + S_2) = \{x + S_2 : x \in F(S_1)\} \cup \{S_1 + y : y \in F(S_2)\} $$
</div><div class="fragment"><div class="theorem"><div class="label">定理</div>Game Sum<hr>對於任意的遊戲 $S_1, S_2$，他們的和的 SG Value 為
$$ SG(S_1 + S_2) = SG(S_1) \oplus SG(S_2) $$
</div></div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li>但其實也沒那麼顯然</li><li class="fragment">畢竟他跟 NIM 還是有點不一樣</li><li class="fragment">NIM 無法走到 Value 更大的狀態</li><li class="fragment">一般遊戲有可能！</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>要證明 $SG(S_1 + S_2) = SG(S_1) \oplus SG(S_2)$，只需要證兩件事</h3><ul><li class="fragment">$S_1 + S_2$ 無法走到 $SG = SG(S_1) \oplus SG(S_2)$ 的狀態。</li><li class="fragment">對於任何 $0 \leq x \leq SG(S_1) \oplus SG(S_2)$，$S_1 + S_2$ 可以走到至少一個 $SG = x$ 的狀態。</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li>因為 $S_1 + S_2$ 盤面也會在有限步內結束，因此新的 Game Graph 也可以表示成 DAG。</li><li>而新 Game Graph 的結束狀態，代表已無步可動，也就是 $S_1, S_2$ 都已處於結束狀態，其 SG Value 為 $0 \oplus 0 = 0$。</li><li>因此我們可以依照拓樸順序來使用數學歸納法，假設所有 $S_1 + S_2$ 可以走到的狀態，都已符合 SG Theorem。 </li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>$S_1 + S_2$ 無法走到 $SG = SG(S_1) \oplus SG(S_2)$ 的狀態。</h3><ul><li class="fragment">恰好挑一邊動一步</li><li class="fragment">該邊的 SG Value 必改變</li><li class="fragment">新狀態兩邊 XOR 起來，必不等於原狀態兩邊 XOR 起來</li><li class="fragment">根據數歸假設，新狀態 SG Value 等於兩邊 SG Value XOR 起來</li><li class="fragment">新 SG Value $\neq SG(S_1) \oplus SG(S_2)$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>對於任何 $0 \leq x \leq SG(S_1) \oplus SG(S_2)$，$S_1 + S_2$ 可以走到至少一個 $SG = x$ 的狀態。</h3><ul><li>動 $S_1$ 的話，可以走到 $0 \sim SG(S_1)-1$ 的狀態。</li><li>動 $S_2$ 的話，可以走到 $0 \sim SG(S_2)-1$ 的狀態。</li><li>我們希望動完之後，兩邊 XOR 起來恰是 $X$。</li><li>也就是說，要證底下這件事情：</li></ul><div class="theorem"><div class="label">定理</div><hr>設 $a, b \geq 0$, 對於所有 $0 \leq x < a \oplus b$，或者存在 $0 \leq a' < a$ 使得 $a' \oplus b = x$，或者存在 $0 \leq b' < b$ 使得 $a \oplus b' = x$。
</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li>假設 $x$ 與 $a \oplus b$ 從左邊數來第一次相異是在第 $k$ 個 Bit</li><li class="fragment">$x < a \oplus b$，因此 $x$ 的第 $k$ Bit 為 $0$ ，$a \oplus b$ 的第 $k$ Bit 為 $1$</li><li class="fragment">$a, b$ 中恰好一數第 $k$ Bit 為 $1$，假設是 $a$</li><li class="fragment">所以 $b$ 的第 $k$ Bit 為 $0$</li><li class="fragment">取 $a' = x \oplus b$</li><li class="fragment">$a'$ 的第 $k$ Bit 為 $0$ ，更左邊的 Bit 都跟 $a$ 相同</li><li class="fragment">$a' < a$ !</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>終於證完了！</h2><h3>那麼來看些題目吧</h3></script></section></section><section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>例題</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>Lieges of Legendre<hr>桌面上有 $N$ 堆壓克力板，每堆分別有 $a_1, a_2, \cdots a_N$ 片。Kevin 和 Nicky 打算用這些壓克力板玩一個遊戲，兩人輪流移動，每次可以從以下兩種操作選一種：<br><br><ul><li>選擇一堆壓克力板，並把最上面的一片拿掉。</li><li>選擇一堆 $2x$ 片 ($x$ 為正整數) 的壓克力板，將它整堆拿掉，並另外補上 $k$ 堆每堆 $x$ 片的壓克力板。</li></ul><br><br>最後無法移動的人就輸了。如果 Kevin 先動，且雙方使用最佳策略，那麼最後誰會獲勝？
($1 \leq N \leq 10^5, 1 \leq k \leq 10^9, 1 \leq a_i \leq 10^9$)</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li class="fragment">每堆壓克力是獨立的</li><li class="fragment">SG Value !</li><li class="fragment">那麼單獨一堆壓克力的 SG Value 是多少呢？</li><li class="fragment">只有至多 $2$ 種操作 => SG Value $\leq 2$</li><li class="fragment">直接用定義算</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template">$$
SG(x) =  
\begin{cases}
\mathrm{mex}\\\{SG(x-1)\\\} &, x \bmod 2 = 1 \\\\
\mathrm{mex}\\\{SG(x-1), SG(x/2) \cdot (k \bmod 2)\\\} &, x \bmod 2 = 0 \textrm{ and } x > 0 \\\\
0 &, x = 0
\end{cases} $$<h2 class="fragment">找規律!</h2><ul class="fragment"><li>$k$ 偶數</li><li>$k$ 奇數</li></ul><br><br><h1 class="fragment"><font color="yellow">^_^;;</font></h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>？克力蛋糕<hr>桌上有一塊<font color="red">巧</font>克力蛋糕，被切成 $N \times M$ 的矩形，左下角為 $(1, 1)$，右上角為 $(N, M)$，而 $(1, 1)$ 的塊被偷換成<font color="green">壓</font>克力蛋糕。兩人輪流操作，每回合可以選一塊剩餘的蛋糕 $(i, j)$ ，並將他右上角 $(i' \geq i, j' \geq j)$ 的蛋糕都吃掉。<font color="green">壓</font>克力蛋糕難吃又傷牙齒，請問先手還是後手會被迫吞下它？</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>後手有可能會必勝嗎？ </h2><ul><li class="fragment">假設可以好了XD</li><li class="fragment">那麼先手選 $(N, M)$，後手必有一個 $(i, j)$ 位置可以應對</li><li class="fragment">然後後手就贏了</li><li class="fragment">欸... 你說後手贏了？ 那先手幹麻不一開始就下 $(i, j)$ 就好了？</li><li class="fragment">反正 $(i, j)$ 的矩形會覆蓋到 $(N, M)$ 嘛</li><li class="fragment">所以事實是：根本就是<font color="red">先手必勝</font>，後手必吃<font color="green">壓克力</font></li><li class="fragment">然後你就會吃一個大大的 <font color="lightblue"> Wrong Answer</font></li><li class="fragment">小心 $N = M = 1$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><div class="prob"><div class="label">例題</div>翻軟幣遊戲<hr><font color="red">錒安</font>最近吃飽沒事幹，跑去銀行把身上的 $10NM$ 元全換成十元硬幣，就為了回家跟<font color="green">鋇蒂</font>玩遊戲。
他把十元硬幣在桌上排成一個 $N \times M$ 的矩形，有些文字朝上，有些人頭朝上。
兩人輪流移動，每次需要做的事有：<br><br><ul><li>任選一個**文字朝上**的硬幣 $(i, j)$，$1 \leq i \leq N, 1 \leq j \leq M$。</li><li>任選一個座標 $(i', j')$ 使得 $0 \leq i' < i, 0 \leq j' < j$。</li><li>把 $(i, j), (i, j'), (i', j), (i', j')$ 四個位置的硬幣都翻面。(如果座標數值有 $0$ ，代表該個硬幣不存在，跳過它。)      </li></ul><br><br><font color="red">錒安</font>先動，不能動的人就輸了。獲勝的人可以拿走所有的硬幣，因此他們兩人都會使用最佳策略，不會故意放水。給定初始盤面，你能預測誰會把錢帶走嗎？
($1 \leq N, M \leq 50$)</div></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><ul><li class="fragment">文字朝上為 $1$ ，人頭朝上為 $0$</li><li class="fragment">這遊戲會在有限步內結束！</li><li class="fragment">每個位置都是獨立的！</li><li class="fragment">... Why?</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>這遊戲會在有限步內結束！</h3><p>把整個盤面表示成二進位數</p>$$f(S) = \sum a_{i, j} 2^{i \cdot M + j}$$<ul><li class="fragment">每次操作 $(i, j)$ 從 1 變 0</li><li class="fragment">剩下三個怎麼變，貢獻都贏不過 $(i, j)$ </li><li class="fragment">$f(S)$ 必減小！每次至少減少 1</li><li class="fragment">$f(S) = 0$ 時遊戲結束</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>每個位置都是獨立的！</h3><ul><li class="fragment">這就比較沒道理了</li><li class="fragment">先把遊戲規則改一下...</li><li class="fragment">$(i, j)$ 數值 $-1$ ，另外三格數值 $+1$</li><li class="fragment">遊戲一樣會結束</li><li class="fragment">這下每格很明顯獨立了吧！</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>但這規則與原本的遊戲等價嗎？</h3><ul><li class="fragment">新規則下，一格數字 $\pm 2$ ，不影響 SG Value</li><li class="fragment">使用數學歸納法</li><li class="fragment">假設二進位數值比 $S$ 小的盤面，新舊規則 SG Value 都相同</li><li class="fragment">對於每個 $S$ 用新規則走到的盤面，把所有 $2$ 換成 $0$，不影響 SG Value</li><li class="fragment">而且會一一對應到一個舊規則走到的盤面</li><li class="fragment">所以新舊規則走得到的盤面的 SG Value 集合相同</li><li class="fragment">盤面 $S$ ，新舊規則 SG Value 相同</li></ul><h3 class="fragment">所以確實可以視為獨立！</h3></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>接下來呢？</h3><ul><li class="fragment">考慮全部只有 $(i, j)$ 是 $1$ 的盤面</li><li class="fragment">枚舉所有操作，使用 SG Theorem 算出到達盤面的 SG Value</li><li class="fragment">利用 $\mathrm{mex}$ 的定義直接計算 $(i, j)$ 盤面的 SG Value</li><li class="fragment">再用這些只有一個 $1$ 的盤面，組成原始盤面</li><li class="fragment">$O(N^2 M^2)$</li></ul></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h2>還想更快嗎？</h2><h1 class="fragment">Nim Product</h1></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><img width="60%" src="img/nimprod.png"></script></section><!DOCTYPE html><section data-markdown><script type="text/template"><h3>性質</h3><ul><li class="fragment">$a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c) $</li><li class="fragment">相異費馬冪次 ($X = 2^{2^k}$) 相乘，等於正常整數相乘</li><li class="fragment">費馬冪次 $X \otimes X = \frac{3}{2}X$ </li></ul></script></section></section><!DOCTYPE html><section data-markdown><script type="text/template"><h1>Q & A</h1></script></section></div></div><script src="js/jquery.js"></script><script src="reveal/lib/js/head.min.js"></script><script src="reveal/js/reveal.js"></script><script src="js/sketch.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,
  //-showNotes: true,

  transition: 'slide', // none/fade/slide/convex/concave/zoom

  // Optional reveal.js plugins
  dependencies: [
    { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'reveal/plugin/zoom-js/zoom.js', async: true },
    { src: 'reveal/plugin/notes/notes.js', async: true },
    { src: 'reveal/plugin/math/math.js', async: true, callback: function() {
      setTimeout( function() {
      MathJax.Hub.Config({
        SVG: {
          scale: 90
          },
        "HTML-CSS": {
          scale: 90
          }
        });
      }, 2000);
    }},
    { src: 'js/dazzleSketch.js', async: true }
  ]
});</script></body></html>